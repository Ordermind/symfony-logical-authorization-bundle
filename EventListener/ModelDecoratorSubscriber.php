<?php

namespace Ordermind\LogicalAuthorizationBundle\EventListener;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;

use Doctrine\Common\Inflector\Inflector;

use Ordermind\DoctrineDecoratorBundle\Event\ModelDecoratorEvents\BeforeMethodCallEvent;
use Ordermind\DoctrineDecoratorBundle\Event\ModelDecoratorEvents\BeforeSaveEvent;
use Ordermind\DoctrineDecoratorBundle\Event\ModelDecoratorEvents\BeforeDeleteEvent;

use Ordermind\LogicalAuthorizationBundle\Services\LogicalAuthorizationModelInterface;

class ModelDecoratorSubscriber implements EventSubscriberInterface {
  protected $laModel;

  public function __construct(LogicalAuthorizationModelInterface $laModel) {
    $this->laModel = $laModel;
  }

  public static function getSubscribedEvents() {
    return array(
      'ordermind_doctrine_decorator.event.model_decorator.before_method_call' => array(
        array('onBeforeMethodCall'),
      ),
      'ordermind_doctrine_decorator.event.model_decorator.before_save' => array(
        array('onBeforeSave'),
      ),
      'ordermind_doctrine_decorator.event.model_decorator.before_delete' => array(
        array('onBeforeDelete'),
      ),
    );
  }

  public function onBeforeMethodCall(BeforeMethodCallEvent $event) {
    static $stored_methods;
    if(!isset($stored_methods)) $stored_methods = array();

    $model = $event->getModel();
    $method = $event->getMethod();
    $arguments = $event->getArguments();
    $field = null;
    $action = null;

    // Support for __get() and __set()
    if($method === '__get') {
      $field = $arguments[0];
      $action = 'get';
    }
    elseif($method === '__set') {
      $field = $arguments[0];
      $action = 'set';
    }

    // Support for field-specific getters and setters generated by Doctrine
    if(!$action) {
      $class = get_class($model);

      if(!isset($stored_methods[$class])) {
        $metadata = $event->getMetadata();
        $field_names = $metadata->getFieldNames();
        $stored_methods[$class] = array();
        foreach($field_names as $field_name) {
          $stored_methods[$class][$field_name] = $this->getFieldMethods($model, $field_name);
        }
      }

      foreach($stored_methods[$class] as $field_name => $methods) {
        if(in_array($method, $methods['getters'])) {
          $field = $field_name;
          $action = 'get';
          break;
        }
        elseif(in_array($method, $methods['setters'])) {
          $field = $field_name;
          $action = 'set';
          break;
        }
      }
    }

    // If the method is a known getter or setter, do a suitable permission check on the model and then on the field.
    if($action === 'get') {
      if(!$this->laModel->checkModelAccess($model, 'read')) {
        $event->setAbort(true);
      }
      if(!$event->getAbort() && !$this->laModel->checkFieldAccess($model, $field, 'get')) {
        $event->setAbort(true);
      }
    }
    elseif($action === 'set') {
      if($event->isNew()) {
        if(!$this->laModel->checkModelAccess($model, 'create')) {
          $event->setAbort(true);
        }
      }
      else {
        if(!$this->laModel->checkModelAccess($model, 'update')) {
          $event->setAbort(true);
        }
      }
      if(!$event->getAbort() && !$this->laModel->checkFieldAccess($model, $field, 'set')) {
        $event->setAbort(true);
      }
    }
  }

  protected function getFieldMethods($model, $field_name) {
    $camelizedFieldName = Inflector::classify($field_name);

    $methods = array(
      'getters' => array(
        "get$camelizedFieldName",
        "is$camelizedFieldName",
      ),
      'setters' => array(
        "set$camelizedFieldName",
      ),
    );

    foreach ($methods as $action => $action_methods) {
      foreach($action_methods as $i => $method) {
        if (!method_exists($model, $method)) {
          unset($methods[$action][$i]);
        }
      }
    }

    return $methods;
  }

  public function onBeforeSave(BeforeSaveEvent $event) {
    $model = $event->getModel();
    if($event->isNew()) {
      if(!$this->laModel->checkModelAccess($model, 'create')) {
        $event->setAbort(true);
      }
    }
    else {
      if(!$this->laModel->checkModelAccess($model, 'update')) {
        $event->setAbort(true);
      }
    }
  }

  public function onBeforeDelete(BeforeDeleteEvent $event) {
    $model = $event->getModel();
    if(!$event->isNew() && !$this->laModel->checkModelAccess($model, 'delete')) {
      $event->setAbort(true);
    }
  }
}